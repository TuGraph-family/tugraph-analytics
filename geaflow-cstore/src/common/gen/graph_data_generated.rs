// Copyright 2023 AntGroup CO., Ltd.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.

// automatically generated by the FlatBuffers compiler, do not modify

// @generated

extern crate flatbuffers;

use self::flatbuffers::{EndianScalar, Follow};

#[allow(unused_imports, dead_code)]
pub mod graph_data {
    use core::{cmp::Ordering, mem};

    use self::flatbuffers::{EndianScalar, Follow};

    extern crate flatbuffers;

    pub enum SecondKeyOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct SecondKey<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for SecondKey<'a> {
        type Inner = SecondKey<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> SecondKey<'a> {
        pub const VT_TS: flatbuffers::VOffsetT = 4;
        pub const VT_GRAPH_INFO: flatbuffers::VOffsetT = 6;
        pub const VT_SEQUENCE_ID: flatbuffers::VOffsetT = 8;
        pub const VT_TARGET_ID: flatbuffers::VOffsetT = 10;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            SecondKey { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args SecondKeyArgs<'args>,
        ) -> flatbuffers::WIPOffset<SecondKey<'bldr>> {
            let mut builder = SecondKeyBuilder::new(_fbb);
            builder.add_sequence_id(args.sequence_id);
            builder.add_graph_info(args.graph_info);
            if let Some(x) = args.target_id {
                builder.add_target_id(x);
            }
            builder.add_ts(args.ts);
            builder.finish()
        }

        #[inline]
        pub fn ts(&self) -> u32 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe { self._tab.get::<u32>(SecondKey::VT_TS, Some(0)).unwrap() }
        }
        #[inline]
        pub fn graph_info(&self) -> u64 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<u64>(SecondKey::VT_GRAPH_INFO, Some(0))
                    .unwrap()
            }
        }
        #[inline]
        pub fn sequence_id(&self) -> u64 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<u64>(SecondKey::VT_SEQUENCE_ID, Some(0))
                    .unwrap()
            }
        }
        #[inline]
        pub fn target_id(&self) -> Option<flatbuffers::Vector<'a, u8>> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(
                        SecondKey::VT_TARGET_ID,
                        None,
                    )
            }
        }
    }

    impl flatbuffers::Verifiable for SecondKey<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<u32>("ts", Self::VT_TS, false)?
                .visit_field::<u64>("graph_info", Self::VT_GRAPH_INFO, false)?
                .visit_field::<u64>("sequence_id", Self::VT_SEQUENCE_ID, false)?
                .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>(
                    "target_id",
                    Self::VT_TARGET_ID,
                    false,
                )?
                .finish();
            Ok(())
        }
    }
    pub struct SecondKeyArgs<'a> {
        pub ts: u32,
        pub graph_info: u64,
        pub sequence_id: u64,
        pub target_id: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
    }
    impl<'a> Default for SecondKeyArgs<'a> {
        #[inline]
        fn default() -> Self {
            SecondKeyArgs {
                ts: 0,
                graph_info: 0,
                sequence_id: 0,
                target_id: None,
            }
        }
    }

    pub struct SecondKeyBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> SecondKeyBuilder<'a, 'b> {
        #[inline]
        pub fn add_ts(&mut self, ts: u32) {
            self.fbb_.push_slot::<u32>(SecondKey::VT_TS, ts, 0);
        }
        #[inline]
        pub fn add_graph_info(&mut self, graph_info: u64) {
            self.fbb_
                .push_slot::<u64>(SecondKey::VT_GRAPH_INFO, graph_info, 0);
        }
        #[inline]
        pub fn add_sequence_id(&mut self, sequence_id: u64) {
            self.fbb_
                .push_slot::<u64>(SecondKey::VT_SEQUENCE_ID, sequence_id, 0);
        }
        #[inline]
        pub fn add_target_id(
            &mut self,
            target_id: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u8>>,
        ) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(SecondKey::VT_TARGET_ID, target_id);
        }
        #[inline]
        pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> SecondKeyBuilder<'a, 'b> {
            let start = _fbb.start_table();
            SecondKeyBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<SecondKey<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for SecondKey<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("SecondKey");
            ds.field("ts", &self.ts());
            ds.field("graph_info", &self.graph_info());
            ds.field("sequence_id", &self.sequence_id());
            ds.field("target_id", &self.target_id());
            ds.finish()
        }
    }
    pub enum GraphDataIndexOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct GraphDataIndex<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for GraphDataIndex<'a> {
        type Inner = GraphDataIndex<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> GraphDataIndex<'a> {
        pub const VT_FID: flatbuffers::VOffsetT = 4;
        pub const VT_OFFSET: flatbuffers::VOffsetT = 6;
        pub const VT_SECOND_KEY_VEC: flatbuffers::VOffsetT = 8;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            GraphDataIndex { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args GraphDataIndexArgs<'args>,
        ) -> flatbuffers::WIPOffset<GraphDataIndex<'bldr>> {
            let mut builder = GraphDataIndexBuilder::new(_fbb);
            builder.add_offset(args.offset);
            if let Some(x) = args.second_key_vec {
                builder.add_second_key_vec(x);
            }
            builder.add_fid(args.fid);
            builder.finish()
        }

        #[inline]
        pub fn fid(&self) -> u32 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<u32>(GraphDataIndex::VT_FID, Some(0))
                    .unwrap()
            }
        }
        #[inline]
        pub fn offset(&self) -> u64 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<u64>(GraphDataIndex::VT_OFFSET, Some(0))
                    .unwrap()
            }
        }
        #[inline]
        pub fn second_key_vec(
            &self,
        ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<SecondKey<'a>>>> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab.get::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<SecondKey>>,
                >>(GraphDataIndex::VT_SECOND_KEY_VEC, None)
            }
        }
    }

    impl flatbuffers::Verifiable for GraphDataIndex<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<u32>("fid", Self::VT_FID, false)?
                .visit_field::<u64>("offset", Self::VT_OFFSET, false)?
                .visit_field::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<SecondKey>>,
                >>("second_key_vec", Self::VT_SECOND_KEY_VEC, false)?
                .finish();
            Ok(())
        }
    }
    pub struct GraphDataIndexArgs<'a> {
        pub fid: u32,
        pub offset: u64,
        pub second_key_vec: Option<
            flatbuffers::WIPOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<SecondKey<'a>>>,
            >,
        >,
    }
    impl<'a> Default for GraphDataIndexArgs<'a> {
        #[inline]
        fn default() -> Self {
            GraphDataIndexArgs {
                fid: 0,
                offset: 0,
                second_key_vec: None,
            }
        }
    }

    pub struct GraphDataIndexBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> GraphDataIndexBuilder<'a, 'b> {
        #[inline]
        pub fn add_fid(&mut self, fid: u32) {
            self.fbb_.push_slot::<u32>(GraphDataIndex::VT_FID, fid, 0);
        }
        #[inline]
        pub fn add_offset(&mut self, offset: u64) {
            self.fbb_
                .push_slot::<u64>(GraphDataIndex::VT_OFFSET, offset, 0);
        }
        #[inline]
        pub fn add_second_key_vec(
            &mut self,
            second_key_vec: flatbuffers::WIPOffset<
                flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<SecondKey<'b>>>,
            >,
        ) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                GraphDataIndex::VT_SECOND_KEY_VEC,
                second_key_vec,
            );
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> GraphDataIndexBuilder<'a, 'b> {
            let start = _fbb.start_table();
            GraphDataIndexBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<GraphDataIndex<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for GraphDataIndex<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("GraphDataIndex");
            ds.field("fid", &self.fid());
            ds.field("offset", &self.offset());
            ds.field("second_key_vec", &self.second_key_vec());
            ds.finish()
        }
    }
    #[inline]
    /// Verifies that a buffer of bytes contains a `GraphDataIndex`
    /// and returns it.
    /// Note that verification is still experimental and may not
    /// catch every error, or be maximally performant. For the
    /// previous, unchecked, behavior use
    /// `root_as_graph_data_index_unchecked`.
    pub fn root_as_graph_data_index(
        buf: &[u8],
    ) -> Result<GraphDataIndex, flatbuffers::InvalidFlatbuffer> {
        flatbuffers::root::<GraphDataIndex>(buf)
    }
    #[inline]
    /// Verifies that a buffer of bytes contains a size prefixed
    /// `GraphDataIndex` and returns it.
    /// Note that verification is still experimental and may not
    /// catch every error, or be maximally performant. For the
    /// previous, unchecked, behavior use
    /// `size_prefixed_root_as_graph_data_index_unchecked`.
    pub fn size_prefixed_root_as_graph_data_index(
        buf: &[u8],
    ) -> Result<GraphDataIndex, flatbuffers::InvalidFlatbuffer> {
        flatbuffers::size_prefixed_root::<GraphDataIndex>(buf)
    }
    #[inline]
    /// Verifies, with the given options, that a buffer of bytes
    /// contains a `GraphDataIndex` and returns it.
    /// Note that verification is still experimental and may not
    /// catch every error, or be maximally performant. For the
    /// previous, unchecked, behavior use
    /// `root_as_graph_data_index_unchecked`.
    pub fn root_as_graph_data_index_with_opts<'b, 'o>(
        opts: &'o flatbuffers::VerifierOptions,
        buf: &'b [u8],
    ) -> Result<GraphDataIndex<'b>, flatbuffers::InvalidFlatbuffer> {
        flatbuffers::root_with_opts::<GraphDataIndex<'b>>(opts, buf)
    }
    #[inline]
    /// Verifies, with the given verifier options, that a buffer of
    /// bytes contains a size prefixed `GraphDataIndex` and returns
    /// it. Note that verification is still experimental and may not
    /// catch every error, or be maximally performant. For the
    /// previous, unchecked, behavior use
    /// `root_as_graph_data_index_unchecked`.
    pub fn size_prefixed_root_as_graph_data_index_with_opts<'b, 'o>(
        opts: &'o flatbuffers::VerifierOptions,
        buf: &'b [u8],
    ) -> Result<GraphDataIndex<'b>, flatbuffers::InvalidFlatbuffer> {
        flatbuffers::size_prefixed_root_with_opts::<GraphDataIndex<'b>>(opts, buf)
    }
    #[inline]
    /// Assumes, without verification, that a buffer of bytes contains a
    /// GraphDataIndex and returns it. # Safety
    /// Callers must trust the given bytes do indeed contain a valid
    /// `GraphDataIndex`.
    pub unsafe fn root_as_graph_data_index_unchecked(buf: &[u8]) -> GraphDataIndex {
        flatbuffers::root_unchecked::<GraphDataIndex>(buf)
    }
    #[inline]
    /// Assumes, without verification, that a buffer of bytes contains a size
    /// prefixed GraphDataIndex and returns it. # Safety
    /// Callers must trust the given bytes do indeed contain a valid size
    /// prefixed `GraphDataIndex`.
    pub unsafe fn size_prefixed_root_as_graph_data_index_unchecked(buf: &[u8]) -> GraphDataIndex {
        flatbuffers::size_prefixed_root_unchecked::<GraphDataIndex>(buf)
    }
    #[inline]
    pub fn finish_graph_data_index_buffer<'a, 'b>(
        fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        root: flatbuffers::WIPOffset<GraphDataIndex<'a>>,
    ) {
        fbb.finish(root, None);
    }

    #[inline]
    pub fn finish_size_prefixed_graph_data_index_buffer<'a, 'b>(
        fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        root: flatbuffers::WIPOffset<GraphDataIndex<'a>>,
    ) {
        fbb.finish_size_prefixed(root, None);
    }
} // pub mod graph_data
